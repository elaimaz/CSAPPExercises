### ***Practice Problem 5.4***:
When we use gcc to compile combine3 with command-line option ‘-O2’, we get code with substantially better CPE performance than with -O1:  

<table>
    <tr>
        <th colspan="3"></th>
        <th colspan="2">Integer</th>
        <th colspan="3">Floating Point</th>
    </tr>
    <tr>
        <th>Function</th>
        <th>Page</th>
        <th>Method</th>
        <th>+</th>
        <th>*</th>
        <th>+</th>
        <th>F*</th>
        <th>D*</th>
    </tr>
    <tr>
        <td>combine3</td>
        <td>491</td>
        <td>Compiled -O1</td>
        <td>6.01</td>
        <td>8.01</td>
        <td>10.01</td>
        <td>11.01</td>
        <td>12.02</td>
    </tr>
    <tr>
        <td>combine3</td>
        <td>491</td>
        <td>Compiled -O2</td>
        <td>3.00</td>
        <td>3.00</td>
        <td>3.00</td>
        <td>4.02</td>
        <td>5.03</td>
    </tr>
    <tr>
        <td>combine4</td>
        <td>493</td>
        <td>Accumulate in temporary</td>
        <td>2.00</td>
        <td>3.00</td>
        <td>3.00</td>
        <td>4.00</td>
        <td>5.00</td>
    </tr>
</table>  

&emsp;We achieve performance comparable to that for combine4, except for the case of integer sum, but even it improves signiﬁcantly. On examining the assembly code generated by the compiler, we ﬁnd an interesting variant for the inner loop:  


```asm
    combine3: data_t = float, OP = *, compiled -O2 i in %rdx, data in %rax, limit in %rbp, dest at %rx12 Product in %xmm0
1    .L560:                      loop:
2       mulss   (%rax,%rdx,4), %xmm0    Multiply product by data[i]
3       addq    $1, %rdx                Increment i
4       cmpq    %rdx, %rbp              Compare limit:i
5       movss   %xmm0, (%r12)           Store product at dest
6       jg      .L560                   If >, goto loop  
```  

We can compare this to the version created with optimization level 1:  

```asm
    combine3: data_t = float, OP = *, compiled -O1 i in %rdx, data in %rax, dest in %rbp
1   .L498:                    loop:
2       movss   (%rbp), %xmm0           Read product from dest
3       mulss   (%rax,%rdx,4), %xmm0    Multiply product by data[i]
4       movss   %xmm0, (%rbp)           Store product at dest
5       movss   %xmm0, (%r12)           Store product at dest
6       addq    $1, %rdx                Increment i
7       cmpq    %rdx, %r12              Compare i:limit
8       jg      .L498                   If >, goto loop  
```  

&emsp;We see that, besides some reordering of instructions, the only difference is that the more optimized version does not contain the movss implementing the read from the location designated by dest (line 2).  

1. How does the role of register %xmm0 differ in these two loops?
2. Will the more optimized version faithfully implement the C code of combine3, including when there is memory aliasing between dest and the vector data?
3. Explain either why this optimization preserves the desired behavior, or give an example where it would produce different results than the less optimized code.

---  

### ***Answear***: 
1. In combine3 -O2 %xmm0 is used to store product result and to pass the value to dest. In combine3 -O1 %xmm0 is used to read dest, and after that is used to store the value at dest twice, one in dest %rbp and other in the temp register %r12.  
2. It will work, even with memory aliasing.
3. It works because data is in %rax and dest at %r12. %rax is never altered, only %r12 with the product value.
